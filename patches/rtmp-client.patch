diff --git a/lib/NetConnection.js b/lib/NetConnection.js
index 3e4be6f259b004c39bce8aca091a167270df0a67..2716919a489146fe16db5cdeba7c5a910a90f95d 100644
--- a/lib/NetConnection.js
+++ b/lib/NetConnection.js
@@ -60,13 +60,15 @@ class NetConnection {
 			return false;
 		}
 		
-		const [, application, instance] = pathname.split('/');
+		const [, application] = pathname.split('/');
 		if (!application) {
 			return false;
 		}
 		
-		const app = `${application}${instance ? '/' : ''}${instance || ''}`;
-		const tcUrl = `${protocol}//${hostname}:${port}/${app}${search}`;
+		// app 只取第一段
+		const app = application;
+		// tcUrl 不包含查询参数（与 ffmpeg 行为一致）
+		const tcUrl = `${protocol}//${hostname}:${port}/${app}`;
 		
 		const client = new Client(hostname, port);
 		this[CLIENT] = client;
@@ -160,8 +162,9 @@ class NetConnection {
 		try {
 			const [, response] = await client.invoke('connect', null, {
 				app,
+				'type': 'nonprivate',
 				tcUrl,
-				'flashVer': 'WIN 32,0,0,465',
+				'flashVer': 'FMLE/3.0 (compatible; FMSc/1.0)',
 				'fpad': false,
 				'capabilities': 15,
 				'audioCodecs': 3191,
@@ -172,6 +175,7 @@ class NetConnection {
 			
 			this.isConnected = true;
 			this.uri = uri;
+			// 启用 PingPong 保活
 			this[PING_PONG].start(client);
 			
 			for (const name of [...new Set(this[SHAREDOBJECT])]) {
diff --git a/lib/MessageStream.js b/lib/MessageStream.js
index 1234567890abcdef..abcdef1234567890 100644
--- a/lib/MessageStream.js
+++ b/lib/MessageStream.js
@@ -70,11 +70,14 @@ class MessageStream extends Duplex {
 		this.transactionId = 1;
 	}
 	
-	send (messageTypeId, messageBody) {
+	// 支持自定义时间戳，timestamp 可选，默认为 null（使用自动计算的时间戳）
+	send (messageTypeId, messageBody, timestamp = null) {
 		this.push({
 			'messageStreamId': this.messageStreamId,
 			messageTypeId,
 			messageBody,
+			// 传递时间戳，如果为 null，ChunkStreamEncoder 会自动计算
+			timestamp,
 		});
 	}
 	
diff --git a/lib/ChunkStream/ChunkStreamEncoder.js b/lib/ChunkStream/ChunkStreamEncoder.js
index 1234567890abcdef..abcdef1234567890 100644
--- a/lib/ChunkStream/ChunkStreamEncoder.js
+++ b/lib/ChunkStream/ChunkStreamEncoder.js
@@ -90,13 +90,40 @@ class ChunkStreamEncoder extends Transform {
 		});
 		
 		this.chunkStreamId = chunkStreamId;
-		this.timestamp = createTimestamp();
+		this.autoTimestamp = createTimestamp();
+		// 跟踪每个 message type 是否已发送过第一帧（用于决定使用 fmt=0 还是 fmt=1）
+		this.sentFirstFrame = new Map();
+		// 保存上一次的消息属性（用于 fmt=1）
+		this.lastMessageProps = null;
 	}
 	
-	_transform ({ messageTypeId, messageStreamId, messageBody }, encoding, callback) {
-		let format = TYPE_0;
-		const timestamp = this.timestamp();
+	_transform ({ messageTypeId, messageStreamId, messageBody, timestamp }, encoding, callback) {
+		// 如果没有提供自定义时间戳，使用自动计算的时间戳
+		const actualTimestamp = timestamp !== null && timestamp !== undefined ? timestamp : this.autoTimestamp();
+		
+		// 判断是否是第一帧（基于 messageTypeId）
+		const isFirstFrame = !this.sentFirstFrame.has(messageTypeId);
+		
+		// 选择格式：
+		// - 第一帧使用 TYPE_0（完整 header，11 字节）
+		// - 后续帧使用 TYPE_1（省略 stream id，7 字节）
+		let format;
+		if (isFirstFrame) {
+			format = TYPE_0;
+			this.sentFirstFrame.set(messageTypeId, true);
+		} else if (this.lastMessageProps && 
+			this.lastMessageProps.messageStreamId === messageStreamId) {
+			// 如果 message stream id 相同，可以使用 TYPE_1
+			format = TYPE_1;
+		} else {
+			// 否则使用 TYPE_0
+			format = TYPE_0;
+		}
+		
+		// 保存当前消息属性供下次使用
+		this.lastMessageProps = { messageTypeId, messageStreamId, messageBody };
+		
 		for (let position = 0; position < messageBody.length; position += CHUNK_SIZE) {
 			const basicHeader = encodeBasicHeader(
 				format,
@@ -104,7 +131,7 @@ class ChunkStreamEncoder extends Transform {
 			);
 			const messageHeader = encodeMessageHeader(
 				format,
-				timestamp,
+				actualTimestamp,
 				messageBody.length,
 				messageTypeId,
 				messageStreamId,
